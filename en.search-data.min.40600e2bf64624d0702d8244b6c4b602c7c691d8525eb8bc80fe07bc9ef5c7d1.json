[{"id":0,"href":"openperouter.github.io/docs/contributing/devenv/","title":"The development environment","section":"Contributing","content":"In order to test and experiment with OpenPERouter, a containerlab and kind based environment is available.\nTo start it, run\nmake deploy The topology of the environment is as follows:\nWith:\nTwo kind nodes connected to a leaf, running OpenPERouter A spine container Two EVPN enabled leaves, leafA and leafB For each leaf, two hosts connected to a type 5 EVPN (VNI 100 and 200) The kubeconfig file required to interact with the cluster is created under bin/kubeconfig.\nThe leaf the kind cluster is connected to is configured with the following parameters:\nIP: 192.168.11.2 ASN: 64512\nand it is configured to accept BGP session from any peer coming from the network 192.168.11.0/24 with ASN 64514.\nMore details, including the IP addresses of all the nodes involved, can be found on the project readme.\nVeth recreation # The development environment faces a significant issue:\nthe nodes of the topology are containers the interfaces that connect the various node are veth pairs if the network namespace wrapping a veth (or any virtual interface) gets deleted, the veth gets deleted too OpenPERouter works by moving one interface from the host (the kind node) to the pod running inside of it Because of this, when the router pod wrapping the interface gets deleted (instead of returning to the host as it would happen with a real interface).\nTo emulate the behavior of a real system, there is a background script which checks for the deletion of the veths and recreates them.\n"},{"id":1,"href":"openperouter.github.io/docs/contributing/code-of-conduct/","title":"Code of Conduct","section":"Contributing","content":" Our Pledge # In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\nOur Standards # Examples of behavior that contributes to creating a positive environment include:\nUsing welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include:\nThe use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others\u0026rsquo; private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities # Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\nScope # This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\nEnforcement # Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting fpaoline@redhat.com and rbryant@redhat.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u0026rsquo;s leadership.\nAttribution # This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n"},{"id":2,"href":"openperouter.github.io/docs/concepts/","title":"Concepts","section":"Docs","content":"This section explains the core concepts behind OpenPERouter and how it integrates with your network infrastructure.\nOverview # OpenPERouter transforms Kubernetes nodes into Provider Edge (PE) routers by running FRR in a dedicated network namespace. This enables EVPN (Ethernet VPN) functionality directly on your Kubernetes nodes, eliminating the need for external PE routers.\nNetwork Architecture # Traditional vs. OpenPERouter Architecture # In traditional deployments, Kubernetes nodes connect to Top-of-Rack (ToR) switches via VLANs, and external PE routers handle EVPN tunneling. OpenPERouter moves this PE functionality directly into the Kubernetes nodes.\nKey Components # OpenPERouter consists of three main components:\nRouter Pod: Runs FRR in a dedicated network namespace Controller Pod: Manages network configuration and orchestrates the router setup Node Labeler: Assigns persistent node indices for resource allocation Underlay Connectivity # Fabric Integration # OpenPERouter integrates with your network fabric by establishing BGP sessions with external routers (typically ToR switches).\nNetwork Interface Management # OpenPERouter works by moving the physical network interface connected to the ToR switch into the router\u0026rsquo;s network namespace:\nThis allows the router to establish direct BGP sessions with the fabric and receive routing information.\nVTEP IP Assignment # Each OpenPERouter instance is assigned a unique VTEP (Virtual Tunnel End Point) IP address from a configured CIDR range. This VTEP IP serves as the identifier for the router within the fabric.\nOpenPERouter establishes a BGP session with the fabric, advertising its VTEP IP to other routers. The VPN address family is enabled on this session, allowing the exchange of EVPN routes required for overlay connectivity.\nOverlay Networks (VNIs) # Virtual Network Identifiers # OpenPERouter supports the creation of multiple VNIs (Virtual Network Identifiers), each corresponding to a separate EVPN tunnel. This enables multi-tenancy and network segmentation.\nOpenPERouter supports the creation of L3 VNIs, allowing the extension of a routed domain via an EVPN overlay:\nIt supports the creation of L2 VNIs, where the veth is directly connected to a layer 2 domain\nAnd it also supports a mixed scenario, where an L2 domain also belongs to a broader L3 domain mapped to an L3 overlay\nL3 VNI Components # For each Layer 3 VNI, OpenPERouter automatically creates:\nVeth Pair: Named after the VNI (e.g., host-200@pe-200) for host connectivity BGP Session: Configured over the veth pair connecting the router to the host, to allow BGP connectivity with the host Linux VRF: Isolates the routing space for each VNI within the router\u0026rsquo;s network namespace VXLAN Interface: Handles tunnel encapsulation/decapsulation Route Translation: Converts between BGP routes and EVPN Type 5 routes IP Allocation Strategy # The IP addresses for the veth pair are allocated from the configured localcidr for each VNI:\nRouter side: Always gets the first IP in the CIDR (e.g., 192.169.11.0) Host side: Each node gets a different IP from the CIDR, starting from the second value (e.g., 192.169.11.15) This consistent allocation strategy of the router IP simplifies configuration across all nodes, as any BGP-speaking component on the host can use the same IP address for the router side of the veth pair.\nControl Plane Operations # Route Advertisement (Host → Fabric) # When a BGP-speaking component (like MetalLB) advertises a prefix to OpenPERouter:\nThe host advertises the route with the veth interface IP as the next hop OpenPERouter learns the route via the BGP session OpenPERouter translates the route to an EVPN Type 5 route The EVPN route is advertised to the fabric with the local VTEP as the next hop Route Reception (Fabric → Host) # When EVPN Type 5 routes are received from the fabric:\nOpenPERouter installs the routes in the VRF corresponding to the VNI OpenPERouter translates the EVPN routes to BGP routes The BGP routes are advertised to the host via the veth interface The host\u0026rsquo;s BGP-speaking component learns and installs the routes Data Plane Operations # Egress Traffic Flow # Traffic destined for networks learned via EVPN follows this path:\nHost Routing: Traffic is redirected to the veth interface corresponding to the VNI Encapsulation: OpenPERouter encapsulates the traffic in VXLAN packets with the appropriate VNI Fabric Routing: The fabric routes the VXLAN packets to the destination VTEP Delivery: The destination endpoint instance receives and processes the traffic Ingress Traffic Flow # VXLAN packets received from the fabric are processed as follows:\nDecapsulation: OpenPERouter removes the VXLAN header VRF Routing: Traffic is routed within the VRF corresponding to the VNI Host Delivery: Traffic is forwarded to the host via the veth interface Final Routing: The host routes the traffic to the appropriate destination L2 VNI # For each Layer 2 VNI, OpenPERouter automatically creates:\nVeth Pair: Named after the VNI (e.g., host-200@pe-200) for Layer 2 host connectivity Linux VRF: Optional, isolates the routing space for each VNI within the router\u0026rsquo;s network namespace VXLAN Interface: Handles tunnel encapsulation/decapsulation Host Interface Management # Given the Layer 2 nature of these connections, OpenPERouter supports multiple interface management options:\nAttaching to an existing bridge: If a bridge already exists and is used by other components, OpenPERouter can attach the veth interface to it Creating a new bridge: OpenPERouter can create a bridge and attach the veth interface directly to it. Direct veth usage: With the understanding that the veth interface may disappear if the pod gets restarted, the veth can be used directly to extend an existing Layer 2 domain Automatic Bridge Creation # The automatic bridge creation is useful for those scenarios where an existing layer 2 domain is extended automatically through the veth interface: when the router pod is deleted or restarted, the veth interface is removed (and then recreated upon reconciliation), while the bridge remains intact, making it a good candidate for attaching to an existing layer 2 domain (i.e. setting it as master of a macvlan multus interface).\nData Plane Operations # The following sections describe complete Layer 2 and Layer 3 scenarios for reference:\nEgress Traffic Flow # When Layer 2 traffic arrives at the veth interface and the destination belongs to the same subnet, the traffic is encapsulated and directed to the VTEP where the endpoint with the MAC address corresponding to the destination IP is located.\nIf the destination IP is on a different subnet, the traffic is routed to the L3 domain that the VNI is connected to, and it\u0026rsquo;s routed via the L3 VNI corresponding to the VRF that the veth interface is attached to.\nIngress Traffic Flow # The ingress flow follows the reverse path of the egress flow. For Layer 2 traffic, VXLAN packets are decapsulated and forwarded to the appropriate veth interface. For Layer 3 traffic, packets are routed through the VRF and then forwarded to the host via the veth interface. The process is straightforward and doesn\u0026rsquo;t require additional explanation beyond what has already been covered in the egress flow descriptions.\n"},{"id":3,"href":"openperouter.github.io/docs/architecture/","title":"Architecture","section":"Docs","content":"This document describes the internal architecture of OpenPERouter and how its components work together to provide EVPN functionality on Kubernetes nodes.\nSystem Overview # OpenPERouter consists of three main components:\nRouter Pod: Runs FRR in a dedicated network namespace Controller Pod: Manages network configuration and orchestrates the router setup Labeler Pod: Assigns persistent node indices for resource allocation Component Architecture # Router Pod # The router pod is the core networking component that provides the actual EVPN functionality.\nThe router pod runs as a Daemonset to allow EVPN connectivity to every node.\nPurpose and Responsibilities # The router pod runs FRR in a dedicated network namespace and is responsible for:\nBGP Sessions: Establishing and maintaining BGP sessions with external routers and host components EVPN Route Processing: Handling EVPN Type 5 route advertisement and reception VXLAN Encapsulation: Managing VXLAN tunnel encapsulation and decapsulation Route Translation: Converting between BGP routes and EVPN routes Network Namespace Management: Operating in an isolated network namespace for security and isolation Container Architecture # The router pod consists of two containers:\nFRR Container: Runs the Free Range Routing daemon and handles all BGP and EVPN operations Reloader Sidecar: Provides an HTTP endpoint that accepts FRR configuration updates and triggers configuration reloads The reloader sidecar container enables dynamic configuration updates without requiring pod restarts, allowing the controller to push new FRR configurations as network conditions change.\nNetwork Configuration Requirements # To enable EVPN functionality, FRR requires specific network interfaces and configurations:\nLinux VRF: Creates isolated Layer 3 routing domains for each VNI Linux Bridge: Connects VXLAN interfaces to the VRF for proper traffic flow VXLAN Interface: Handles tunnel encapsulation/decapsulation with the configured VNI VTEP Loopback: Provides the VTEP IP address for tunnel endpoint identification FRR Configuration # The router pod configures FRR with the following key settings:\nVTEP Advertisement: Advertises the local VTEP IP to the fabric for route reachability EVPN Address Family: Enables EVPN route exchange with external routers Host BGP Sessions: Establishes BGP sessions with components running on the host (L3VNIs) Route Policies: Configures import/export policies for proper route filtering For detailed FRR configuration information, refer to the official FRR documentation.\nController Pod # The controller pod is the orchestration component that manages the router configuration and network setup.\nPurpose and Responsibilities # The controller pod handles all the complex network configuration logic and is responsible for:\nResource Reconciliation: Watches and reconciles OpenPERouter Custom Resources (CRs) Network Interface Management: Moves host interfaces into the router\u0026rsquo;s network namespace VNI Setup: Creates and configures network interfaces for each VNI Configuration Generation: Generates and applies FRR configuration State Management: Maintains the desired state of network configurations Reconciliation Process # The controller follows a specific sequence when reconciling VNI configurations:\nNetwork Interface Creation: For each VNI, creates the required network interfaces (bridge, VRF, VXLAN) for FRR operation L3 Veth Pair Setup: Creates veth pairs to connect VRFs to the host, assigns IPs from the localCIDR, and moves one end to the router\u0026rsquo;s namespace L2 Veth Pair Setup: Creates veth pairs to connect VRFs to the host, enslaves the PERouter side to the bridge corresponding to the L2 domain, eventually creates a bridge on the host, and enslaves the host side to the bridge it just created or to an existing bridge (configurable) Configuration Deployment: Generates the FRR configuration and sends it to the router pod for application When reconciling an Underlay instance, the controller moves the host interface connected to the external router into the router\u0026rsquo;s pod network namespace.\nNode Labeler # The node labeler is a critical component that ensures consistent resource allocation across the cluster.\nPurpose and Responsibilities # The node labeler provides persistent node indexing and is responsible for:\nNode Index Assignment: Assigns a unique, persistent index to each node in the cluster Resource Allocation: Enables deterministic allocation of VTEP IPs and local CIDRs State Persistence: Ensures resource allocations remain consistent across pod restarts and cluster reboots Index Persistence # The node labeler persists the assigned index as a Kubernetes node label, making it available to other components. This ensures:\nConsistency: Each node maintains its assigned index even after pod rescheduling Deterministic Allocation: VTEP IPs and CIDRs are allocated based on the persistent index "},{"id":4,"href":"openperouter.github.io/docs/installation/","title":"Installation","section":"Docs","content":"This guide covers the installation of OpenPERouter using different deployment methods.\nPrerequisites # Before installing OpenPERouter, ensure you have:\nA Kubernetes cluster (v1.20 or later) kubectl configured to communicate with your cluster Cluster administrator privileges (for creating namespaces and CRDs) Network interfaces configured for BGP peering with external routers For OpenShift: oc CLI tool and cluster admin access Installation Methods # OpenPERouter offers several deployment methods to suit different environments and preferences:\nMethod 1: All-in-One Manifests (Quick Start) # The simplest way to install OpenPERouter is using the all-in-one manifests. This method is ideal for testing and development environments.\nStandard Installation (containerd) # kubectl apply -f https://raw.githubusercontent.com/openperouter/openperouter/refs/heads/main/config/all-in-one/openpe.yaml CRI-O Variant # If your cluster uses CRI-O as the container runtime:\nkubectl apply -f https://raw.githubusercontent.com/openperouter/openperouter/refs/heads/main/config/all-in-one/crio.yaml Method 2: Kustomize Installation # Kustomize provides more flexibility for customizing the deployment. This method is recommended for production environments.\nDefault Configuration # Create a kustomization.yaml file:\nnamespace: openperouter-system resources: - github.com/openperouter/openperouter/config/default?ref=main Then apply it:\nkubectl apply -k . CRI-O Variant with Kustomize # namespace: openperouter-system resources: - github.com/openperouter/openperouter/config/crio?ref=main Method 3: Helm Installation # Helm provides the most flexibility for configuration and is recommended for production deployments.\nAdd the Helm Repository # helm repo add openperouter https://openperouter.github.io/openperouter helm repo update Install OpenPERouter # helm install openperouter openperouter/openperouter Customize Installation # You can customize the installation by creating a values file:\n# values.yaml openperouter: logLevel: \u0026#34;info\u0026#34; cri: \u0026#34;containerd\u0026#34; frr: image: repository: \u0026#34;quay.io/frrouting/frr\u0026#34; tag: \u0026#34;10.2.1\u0026#34; Then install with custom values:\nhelm install openperouter openperouter/openperouter -f values.yaml Platform-Specific Instructions # OpenShift # When running on OpenShift, additional Security Context Constraints (SCCs) must be configured:\noc adm policy add-scc-to-user privileged -n openperouter-system -z controller oc adm policy add-scc-to-user privileged -n openperouter-system -z router Verification # After installation, verify that all components are running correctly:\nkubectl get pods -n openperouter-system You should see pods for:\nopenperouter-controller-* (controller daemonset) openperouter-router-* (router daemonset) openperouter-nodemarker-* (node labeler deployment) Next Steps # After successful installation:\nConfigure the underlay connection to your external router Set up VNI configurations for your EVPN overlays Test the integration with BGP-speaking components For troubleshooting, check the contributing guide for development environment setup and debugging information.\n"},{"id":5,"href":"openperouter.github.io/docs/configuration/","title":"Configuration","section":"Docs","content":"OpenPERouter requires two main configuration components: the Underlay configuration for external router connectivity and VNI configurations for EVPN overlays.\nAll Custom Resources (CRs) must be created in the same namespace where OpenPERouter is deployed (typically openperouter-system).\nUnderlay Configuration # The underlay configuration establishes BGP sessions with external routers (typically Top-of-Rack switches) and defines the VTEP IP allocation strategy.\nBasic Underlay Configuration # apiVersion: openpe.openperouter.github.io/v1alpha1 kind: Underlay metadata: name: underlay namespace: openperouter-system spec: asn: 64514 vtepcidr: 100.65.0.0/24 nics: - toswitch neighbors: - asn: 64512 address: 192.168.11.2 Configuration Fields # Field Type Description Required asn integer Local ASN for BGP sessions Yes vtepcidr string CIDR block for VTEP IP allocation Yes nics array List of network interface names to move to router namespace Yes neighbors array List of BGP neighbors to peer with Yes VTEP IP Allocation # The vtepcidr field defines the IP range used for VTEP (Virtual Tunnel End Point) addresses. OpenPERouter automatically assigns a unique VTEP IP to each node from this range. For example, with 100.65.0.0/24:\nNode 1: 100.65.0.1 Node 2: 100.65.0.2 Node 3: 100.65.0.3 etc. L3 VNI Configuration # L3 VNI (Virtual Network Identifier) configurations define EVPN L3 overlays. Each L3VNI creates a separate routing domain and BGP session with the host.\nBasic L3VNI Configuration # apiVersion: openpe.openperouter.github.io/v1alpha1 kind: L3VNI metadata: name: blue namespace: openperouter-system spec: asn: 64514 vni: 200 localcidr: 192.169.11.0/24 hostasn: 64515 Configuration Fields # Field Type Description Required asn integer Router ASN for BGP session with host Yes vni integer Virtual Network Identifier (1-16777215) Yes localcidr string CIDR for veth pair IP allocation Yes hostasn integer Host ASN for BGP session Yes Multiple VNIs Example # You can create multiple VNIs for different network segments:\n# Production VNI apiVersion: openpe.openperouter.github.io/v1alpha1 kind: L3VNI metadata: name: signal namespace: openperouter-system spec: asn: 64514 vni: 100 localcidr: 192.168.10.0/24 hostasn: 64515 --- # Development VNI apiVersion: openpe.openperouter.github.io/v1alpha1 kind: L3VNI metadata: name: oam namespace: openperouter-system spec: asn: 64514 vni: 200 localcidr: 192.168.20.0/24 hostasn: 64515 What Happens During Reconciliation # When you create or update VNI configurations, OpenPERouter automatically:\nCreates Network Interfaces: Sets up VXLAN interface and Linux VRF named after the VNI Establishes Connectivity: Creates veth pair and moves one end to the router\u0026rsquo;s namespace Assigns IP Addresses: Allocates IPs from the localcidr range: Router side: First IP in the CIDR (e.g., 192.169.11.0) Host side: Each node gets a free IP in the CIDR, starting from the second (e.g., 192.169.11.15) Creates BGP Session: Opens BGP session between router and host using the specified ASNs L2VNI Configuration # L2VNIs provide Layer 2 connectivity across nodes using EVPN tunnels. Unlike L3VNIs, L2VNIs extend Layer 2 domains rather than routing domains.\nConfiguration Fields # Field Type Description Required vni integer Virtual Network Identifier for the EVPN tunnel Yes vrf string Name of the VRF to associate with this L2VNI Yes hostMaster.type string Type of host interface management (bridge or direct) Yes hostMaster.autoCreate boolean Whether to automatically create a bridge if type is bridge No hostMaster.bridgeName string Name of the bridge to attach to (if not auto-creating) No L2VNI Example # apiVersion: openpe.openperouter.github.io/v1alpha1 kind: L2VNI metadata: name: l2red namespace: openperouter-system spec: vni: 210 vrf: red hostMaster: type: bridge autoCreate: true What Happens During Reconciliation # When you create or update VNI configurations, OpenPERouter automatically:\nCreates Network Interfaces: Sets up VXLAN interface and Linux VRF named after the VNI Establishes Connectivity: Creates veth pair and moves one end to the router\u0026rsquo;s namespace Enslaves the veth: the veth is connected to the bridge corresponding to the l2 domain Optionally creates a bridge on the host: if hostMaster.autoCreate is set to true Optionally connects the host veth to the bridge on the host: if hostMaster.autoCreate is set to true or name is set API Reference # For detailed information about all available configuration fields, validation rules, and API specifications, see the API Reference documentation.\n"},{"id":6,"href":"openperouter.github.io/docs/examples/","title":"Examples","section":"Docs","content":"This section provides practical examples of integrating OpenPERouter with various BGP-speaking components commonly used in Kubernetes environments.\nOverview # OpenPERouter behaves exactly like a physical Provider Edge (PE) router, enabling seamless integration with any BGP-speaking component. This router-like behavior ensures that integration is straightforward and follows standard BGP peering practices.\nPrerequisites # All examples in this section assume you have:\nOpenPERouter installed and configured (see Installation) A development environment with two L3 VNIs available from the fabric Basic understanding of BGP and EVPN concepts Development Environment Setup # The examples use a development environment with the following topology:\nThis environment provides:\nTwo L3 VNIs (100 and 200) configured in the fabric Leaf switches (leafA and leafB) with BGP peering A kind cluster for testing OpenPERouter integration Base OpenPERouter Configuration # Before running any integration examples, you need to configure OpenPERouter with the appropriate underlay and VNI settings.\nUnderlay Configuration # Configure the underlay to peer with the kind-leaf node:\napiVersion: openpe.openperouter.github.io/v1alpha1 kind: Underlay metadata: name: underlay namespace: openperouter-system spec: asn: 64514 vtepcidr: 100.65.0.0/24 nics: - toswitch neighbors: - asn: 64512 address: 192.168.11.2 Configuration Details:\nASN: 64514 (OpenPERouter\u0026rsquo;s ASN) VTEP CIDR: 100.65.0.0/24 (VTEP IP allocation range) Interface: toswitch (network interface to the fabric) Neighbor: 192.168.11.2 with ASN 64512 (kind-leaf node) VNI Configurations # Create two VNIs that match the fabric configuration:\n# Red VNI (VNI 100) apiVersion: openpe.openperouter.github.io/v1alpha1 kind: VNI metadata: name: red namespace: openperouter-system spec: asn: 64514 vni: 100 localcidr: 192.169.10.0/24 hostasn: 64515 --- # Blue VNI (VNI 200) apiVersion: openpe.openperouter.github.io/v1alpha1 kind: VNI metadata: name: blue namespace: openperouter-system spec: asn: 64514 vni: 200 localcidr: 192.169.11.0/24 hostasn: 64515 VNI Details:\nRed VNI: VNI 100 with CIDR 192.169.10.0/24 Blue VNI: VNI 200 with CIDR 192.169.11.0/24 Host ASN: 64515 (for BGP sessions with host components) Available Examples # MetalLB Integration # Learn how to integrate OpenPERouter with MetalLB to advertise LoadBalancer services across the EVPN fabric.\nKey Features:\nLoadBalancer service advertisement EVPN Type 5 route generation Cross-fabric service reachability View MetalLB Integration Example →\n"},{"id":7,"href":"openperouter.github.io/docs/examples/metallb/","title":"MetalLB Integration","section":"Examples","content":"This example demonstrates how to integrate OpenPERouter with MetalLB to advertise LoadBalancer services across the EVPN fabric, enabling external access to Kubernetes services.\nOverview # MetalLB provides load balancing for Kubernetes services by advertising service IPs via BGP. When integrated with OpenPERouter, these BGP routes are automatically converted to EVPN Type 5 routes, making the services reachable across the entire fabric.\nPrerequisites # Before proceeding with this integration:\nOpenPERouter Configuration: Ensure OpenPERouter is properly configured with underlay and VNI settings (see base configuration) MetalLB Installation: Install MetalLB in your cluster Network Planning: Plan your service IP ranges for each VNI Integration Architecture # BGP Peering Setup # MetalLB establishes BGP sessions with OpenPERouter through the veth interfaces created for each VNI. Since the router-side IP is consistent across all nodes, you only need one BGPPeer configuration per VNI.\nRoute Flow # Service Creation: Kubernetes LoadBalancer service is created MetalLB Advertisement: MetalLB advertises the service IP via BGP to OpenPERouter EVPN Conversion: OpenPERouter converts the BGP route to EVPN Type 5 route Fabric Distribution: EVPN route is distributed across the fabric External Access: External hosts can reach the service through the fabric Configuration Steps # Step 1: Configure BGP Peers # Create BGPPeer resources for each VNI. Since the router IP is consistent across nodes, one peer configuration per VNI is sufficient.\nRed VNI (VNI 100) BGP Peer # apiVersion: metallb.io/v1beta2 kind: BGPPeer metadata: name: red-vni-peer namespace: metallb-system spec: myASN: 64515 peerASN: 64514 peerAddress: 192.169.10.0 Blue VNI (VNI 200) BGP Peer # apiVersion: metallb.io/v1beta2 kind: BGPPeer metadata: name: blue-vni-peer namespace: metallb-system spec: myASN: 64515 peerASN: 64514 peerAddress: 192.169.11.0 Configuration Details:\nmyASN: 64515 (MetalLB\u0026rsquo;s ASN, matches the host ASN in OpenPERouter VNI config) peerASN: 64514 (OpenPERouter\u0026rsquo;s ASN) peerAddress: Router-side veth IP for each VNI Step 2: Configure IP Address Pools # Create IP address pools for your LoadBalancer services. You can create separate pools for different VNIs or use a single pool.\nSingle Pool Configuration # apiVersion: metallb.io/v1beta1 kind: IPAddressPool metadata: name: service-pool namespace: metallb-system spec: addresses: - 192.168.10.0/24 Multiple Pools for Different VNIs # # Red VNI Pool apiVersion: metallb.io/v1beta1 kind: IPAddressPool metadata: name: red-vni-pool namespace: metallb-system spec: addresses: - 192.168.10.0/24 --- # Blue VNI Pool apiVersion: metallb.io/v1beta1 kind: IPAddressPool metadata: name: blue-vni-pool namespace: metallb-system spec: addresses: - 192.168.20.0/24 Step 3: Configure BGP Advertisement # Create BGPAdvertisement resources to enable route advertisement.\nBasic Advertisement # apiVersion: metallb.io/v1beta1 kind: BGPAdvertisement metadata: name: service-advertisement namespace: metallb-system spec: ipAddressPools: - service-pool VNI-Specific Advertisement # apiVersion: metallb.io/v1beta1 kind: BGPAdvertisement metadata: name: red-vni-advertisement namespace: metallb-system spec: ipAddressPools: - red-vni-pool communities: - 64514:100 # VNI-specific community Route Advertisement Flow # Once configured, the integration works as follows:\nService Creation: Kubernetes LoadBalancer service is created with an IP from the pool MetalLB Processing: MetalLB assigns an IP and starts advertising it via BGP BGP Session: MetalLB advertises the route to OpenPERouter through the veth interface EVPN Conversion: OpenPERouter converts the BGP route to EVPN Type 5 route Fabric Distribution: The EVPN route is distributed to all fabric routers External Reachability: External hosts can now reach the service through the fabric Traffic Flow # When external traffic reaches the service:\nExternal Request: External host sends traffic to the service IP Fabric Routing: Fabric routes the traffic to the appropriate VTEP VXLAN Encapsulation: Traffic is encapsulated in VXLAN with the appropriate VNI OpenPERouter Processing: OpenPERouter receives and decapsulates the traffic Service Delivery: Traffic is forwarded to the Kubernetes service endpoint "},{"id":8,"href":"openperouter.github.io/docs/api-reference/","title":"API Reference","section":"Docs","content":" API Reference # Packages # openpe.openperouter.github.io/v1alpha1 openpe.openperouter.github.io/v1alpha1 # Package v1alpha1 contains API Schema definitions for the openpe v1alpha1 API group.\nResource Types # L2VNI L3VNI Underlay HostMaster # Appears in:\nL2VNISpec Field Description Default Validation name string Name of the host interface. Must match VRF name validation if set. MaxLength: 15 Pattern: ^[a-zA-Z][a-zA-Z0-9_-]*$ type string Type of the host interface. Currently only \u0026ldquo;bridge\u0026rdquo; is supported. Enum: [bridge] autocreate boolean If true, the interface will be created automatically if not present.The name of the bridge is of the form br-hs-. false L2VNI # L2VNI represents a VXLan VNI to receive EVPN type 2 routes from.\nField Description Default Validation apiVersion string openpe.openperouter.github.io/v1alpha1 kind string L2VNI metadata ObjectMeta Refer to Kubernetes API documentation for fields of metadata. spec L2VNISpec status L2VNIStatus L2VNISpec # L2VNISpec defines the desired state of VNI.\nAppears in:\nL2VNI Field Description Default Validation vrf string VRF is the name of the linux VRF to be used inside the PERouter namespace.The field is optional, if not set it the name of the VNI instance will be used. MaxLength: 15 Pattern: ^[a-zA-Z][a-zA-Z0-9_-]*$ vni integer VNI is the VXLan VNI to be used Maximum: 4.294967295e+09 Minimum: 0 vxlanport integer VXLanPort is the port to be used for VXLan encapsulation. 4789 hostmaster HostMaster HostMaster is the interface on the host the veth should be enslaved to.If not set, the host veth will not be enslaved to any interface and it must beenslaved manually (or by some other means). This is useful if another controlleris leveraging the host interface for the VNI. l2gatewayip string L2GatewayIP is the IP address to be used for the L2 gateway. When this is set, thebridge the veths are enslaved to will be configured with this IP address, effectivelyacting as a distributed gateway for the VNI. L2VNIStatus # VNIStatus defines the observed state of VNI.\nAppears in:\nL2VNI L3VNI # L3VNI represents a VXLan L3VNI to receive EVPN type 5 routes from.\nField Description Default Validation apiVersion string openpe.openperouter.github.io/v1alpha1 kind string L3VNI metadata ObjectMeta Refer to Kubernetes API documentation for fields of metadata. spec L3VNISpec status L3VNIStatus L3VNISpec # L3VNISpec defines the desired state of VNI.\nAppears in:\nL3VNI Field Description Default Validation asn integer ASN is the local AS number to use to establish a BGP session withthe default namespace. Maximum: 4.294967295e+09 Minimum: 1 vrf string VRF is the name of the linux VRF to be used inside the PERouter namespace.The field is optional, if not set it the name of the VNI instance will be used. MaxLength: 15 Pattern: ^[a-zA-Z][a-zA-Z0-9_-]*$ hostasn integer ASN is the expected AS number for a BGP speaking component running inthe default network namespace. If not set, the ASN field is going to be used. Maximum: 4.294967295e+09 Minimum: 0 vni integer VNI is the VXLan VNI to be used Maximum: 4.294967295e+09 Minimum: 0 localcidr string LocalCIDR is the CIDR to be used for the veth pairto connect with the default namespace. The interface underthe PERouter side is going to use the first IP of the cidr on all the nodes. vxlanport integer VXLanPort is the port to be used for VXLan encapsulation. 4789 L3VNIStatus # L3VNIStatus defines the observed state of L3VNI.\nAppears in:\nL3VNI Neighbor # Neighbor represents a BGP Neighbor we want FRR to connect to.\nAppears in:\nUnderlaySpec Field Description Default Validation asn integer ASN is the AS number to use for the local end of the session. Maximum: 4.294967295e+09 Minimum: 1 address string Address is the IP address to establish the session with. port integer Port is the port to dial when establishing the session.Defaults to 179. Maximum: 16384 Minimum: 0 password string Password to be used for establishing the BGP session.Password and PasswordSecret are mutually exclusive. passwordSecret string PasswordSecret is name of the authentication secret for the neighbor.the secret must be of type \u0026ldquo;kubernetes.io/basic-auth\u0026rdquo;, and created in thesame namespace as the perouter daemon. The password is stored in thesecret as the key \u0026ldquo;password\u0026rdquo;.Password and PasswordSecret are mutually exclusive. holdTime Duration HoldTime is the requested BGP hold time, per RFC4271.Defaults to 180s. keepaliveTime Duration KeepaliveTime is the requested BGP keepalive time, per RFC4271.Defaults to 60s. connectTime Duration Requested BGP connect time, controls how long BGP waits between connection attempts to a neighbor. ebgpMultiHop boolean EBGPMultiHop indicates if the BGPPeer is multi-hops away. Underlay # Underlay is the Schema for the underlays API.\nField Description Default Validation apiVersion string openpe.openperouter.github.io/v1alpha1 kind string Underlay metadata ObjectMeta Refer to Kubernetes API documentation for fields of metadata. spec UnderlaySpec status UnderlayStatus UnderlaySpec # UnderlaySpec defines the desired state of Underlay.\nAppears in:\nUnderlay Field Description Default Validation asn integer ASN is the local AS number to use for the session with the TOR switch. Maximum: 4.294967295e+09 Minimum: 1 vtepcidr string VTEPCIDR is CIDR to be used to assign IPs to the local VTEP on each node. neighbors Neighbor array Neighbors is the list of external neighbors to peer with. MinItems: 1 nics string array Nics is the list of physical nics to move under the PERouter namespace to connectto external routers. MinItems: 1 UnderlayStatus # UnderlayStatus defines the observed state of Underlay.\nAppears in:\nUnderlay "},{"id":9,"href":"openperouter.github.io/docs/contributing/","title":"Contributing","section":"Docs","content":"We would love to hear from you! Here are some places you can find us.\nIssue Tracker # Use the GitHub issue tracker to file bugs and features request.\nContributing # Contributions are more than welcome! Here\u0026rsquo;s some information to get you started.\nCode of Conduct # This project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.\nCode changes # Before you make significant code changes, please consider opening a pull request with a proposed design in the design/ directory. That should reduce the amount of time required for code review. If you don\u0026rsquo;t have a full design proposal ready, feel free to open an issue to discuss what you would like to do.\nAll submissions require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.\nCertificate of Origin # By contributing to this project you agree to the Developer Certificate of Origin (DCO). This document was created by the Linux Kernel community and is a simple statement that you, as a contributor, have the legal right to make the contribution. See the DCO file for details.\nCode organization # The OpenPERouter codebase is organized to separate core functionality, supporting libraries, deployment resources, and documentation. Here is an overview of the most relevant directories:\ncmd/ – Contains the main entry points for the OpenPERouter binaries. Please check the architecture documentation for an overview of the binaries and their responsibilities. api/ – Defines the Kubernetes Custom Resource Definitions (CRDs) and API types used by OpenPERouter. internal/ – Contains internal packages that implement the core logic of OpenPERouter. This directory is not intended for use outside the project and is structured as follows: controller/ – Implements the controllers logic, including reconciliation loops and resource management for OpenPERouter components. conversion/ – Handles conversion logic between different API versions or resource representations. frr/ – Contains code related to FRRouting (FRR) integration, such as configuration generation and management. frrconfig/ – Manages FRR configuration files and templates used by OpenPERouter. hostnetwork/ – Provides utilities and logic for managing host networking aspects required by FRR to make EVPN work. ipam/ – Implements IP Address Management (IPAM) logic, including allocation and tracking of IP addresses. operator/ – Contains the Kubernetes operator for OpenPERouter, including its main code, API, and configuration. charts/ – Helm charts for deploying OpenPERouter and its components. e2etests/ – End-to-end test suite for validating OpenPERouter functionality. This structure helps keep the project modular, maintainable, and easy to navigate for contributors and users alike.\nIn addition to code, there\u0026rsquo;s deployment configuration and documentation:\nHelm charts: The charts/ directory contains Helm charts for deploying OpenPERouter and its components. These charts provide a convenient way to install, upgrade, and manage OpenPERouter in Kubernetes environments. Refer to the README in the charts/ directory for usage instructions and configuration options.\nConfiguration: Deployment and runtime configuration files are located in the operator/config/ directory. This includes manifests for Kubernetes resources, sample CRs, and other configuration templates. Review these files to understand how to customize OpenPERouter for your environment.\nWebsite and Documentation: The website/ directory contains the source for the OpenPERouter documentation site. Contributions to documentation, guides, and tutorials are welcome. To propose changes, edit the relevant Markdown files and submit a pull request.\nBuilding and running the code # Start by fetching the OpenPERouter repository, with git clone https://github.com/openperouter/openperouter.\nFrom there, you can build the docker image locally by calling\nmake docker-build A comprehensive test environment can be deployed locally by using\nmake deploy Check the dev environment documentation for more details.\nAfter deploying the ContainerLab environment together with Kind, the kubeconfig will be available at bin/kubeconfig.\nRunning the tests locally # You can run unit tests locally with:\nmake test To run the end-to-end (e2e) tests, first ensure that the local development environment is running (see above), then execute:\nmake e2etest This will run the e2e test suite against your local environment.\nCommit Messages # The following are our commit message guidelines:\nLine wrap the body at 72 characters For a more complete discussion of good git commit message practices, see https://chris.beams.io/posts/git-commit/. Extending the end to end test suite # When adding a new feature, or modifying a current one, consider adding a new test to the test suite located in /e2etest. Each feature should come with enough unit test / end to end coverage to make us confident of the change.\n"}]